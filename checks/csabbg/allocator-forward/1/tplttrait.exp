tplttrait.cpp:8:27: warning: AL01: Class 'D' uses allocators but does not have an allocator() method
template <class T> struct D {             D(bslma::Allocator* alloc = 0) { } };
                          ^
tplttrait.cpp:8:78: note: AL01: Allocator method declaration for class D

  public:
    // PUBLIC ACCESSORS
    bslma::Allocator *allocator() const;

template <class T> struct D {             D(bslma::Allocator* alloc = 0) { } };
                                                                             ^
tplttrait.cpp:8:27: warning: AP02: Class 'D' needs d_allocator_p member
template <class T> struct D {             D(bslma::Allocator* alloc = 0) { } };
                          ^
tplttrait.cpp:8:78: note: AP02: Allocator member declaration for class D

  private:
    // PRIVATE DATA
    bslma::Allocator *d_allocator_p;

template <class T> struct D {             D(bslma::Allocator* alloc = 0) { } };
                                                                             ^
tplttrait.cpp:8:27: warning: AC02: Implicit copy constructor cannot be called with an allocator as the final argument
template <class T> struct D {             D(bslma::Allocator* alloc = 0) { } };
                          ^
tplttrait.cpp:8:78: note: AC02: Version with allocator

  public:
    // PUBLIC CREATORS
    D(const D& original, bslma::Allocator *basicAllocator = 0);

template <class T> struct D {             D(bslma::Allocator* alloc = 0) { } };
                                                                             ^
tplttrait.cpp:9:27: warning: AL01: Class 'E' uses allocators but does not have an allocator() method
                   struct E {             E(bslma::Allocator* alloc = 0) { } };
                          ^
tplttrait.cpp:9:78: note: AL01: Allocator method declaration for class E

                     public:
                       // PUBLIC ACCESSORS
                       bslma::Allocator *allocator() const;
                   
                   struct E {             E(bslma::Allocator* alloc = 0) { } };
                                                                             ^
tplttrait.cpp:9:27: warning: AP02: Class 'E' needs d_allocator_p member
                   struct E {             E(bslma::Allocator* alloc = 0) { } };
                          ^
tplttrait.cpp:9:78: note: AP02: Allocator member declaration for class E

                     private:
                       // PRIVATE DATA
                       bslma::Allocator *d_allocator_p;
                   
                   struct E {             E(bslma::Allocator* alloc = 0) { } };
                                                                             ^
tplttrait.cpp:9:27: warning: AC02: Implicit copy constructor cannot be called with an allocator as the final argument
                   struct E {             E(bslma::Allocator* alloc = 0) { } };
                          ^
tplttrait.cpp:9:78: note: AC02: Version with allocator

                     public:
                       // PUBLIC CREATORS
                       E(const E& original, bslma::Allocator *basicAllocator = 0);
                   
                   struct E {             E(bslma::Allocator* alloc = 0) { } };
                                                                             ^
tplttrait.cpp:10:63: warning: MA02: Allocator not passed to member e
struct A { E e; D<int> d; C c; B<int> b;  A(bslma::Allocator* alloc = 0) { } };
                                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~
tplttrait.cpp:10:63: warning: MA02: Allocator not passed to member d
struct A { E e; D<int> d; C c; B<int> b;  A(bslma::Allocator* alloc = 0) { } };
                                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~
tplttrait.cpp:10:8: warning: AL01: Class 'A' uses allocators but does not have an allocator() method
struct A { E e; D<int> d; C c; B<int> b;  A(bslma::Allocator* alloc = 0) { } };
       ^
tplttrait.cpp:10:78: note: AL01: Allocator method declaration for class A

  public:
    // PUBLIC ACCESSORS
    bslma::Allocator *allocator() const;

struct A { E e; D<int> d; C c; B<int> b;  A(bslma::Allocator* alloc = 0) { } };
                                                                             ^
tplttrait.cpp:10:8: warning: AC02: Implicit copy constructor cannot be called with an allocator as the final argument
struct A { E e; D<int> d; C c; B<int> b;  A(bslma::Allocator* alloc = 0) { } };
       ^
tplttrait.cpp:10:78: note: AC02: Version with allocator

  public:
    // PUBLIC CREATORS
    A(const A& original, bslma::Allocator *basicAllocator = 0);

struct A { E e; D<int> d; C c; B<int> b;  A(bslma::Allocator* alloc = 0) { } };
                                                                             ^
10 warnings generated.
